<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>AR-video con sonido - calibraci칩n</title>

    <!-- A-Frame + AR.js (versiones compatibles con tu base) -->
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <!-- Gestos pinch / rotate (como en tu base original) -->
    <script src="https://raw.githack.com/AR-js-org/studio-backend/master/src/modules/marker/tools/gesture-detector.js"></script>
    <script src="https://raw.githack.com/AR-js-org/studio-backend/master/src/modules/marker/tools/gesture-handler.js"></script>

    <style>
      /* Overlay "Toca para activar audio" */
      #overlay{
        position:fixed; inset:0;
        display:flex; align-items:center; justify-content:center;
        background:transparent;
        color:#fff; font-family:sans-serif; font-size:1.25rem;
        text-shadow:0 0 6px #000;
        z-index:999; text-align:center; padding:1rem;
        pointer-events:auto;
      }
    </style>

    <!--
      selectCameraAndStart:
      - pide permiso con baja resoluci칩n (evita telefoto y zoom digital)
      - enumera c치maras y busca nombre "wide" / "ultra"
      - si encuentra wide, pide stream con ese deviceId y lo asigna al arToolkitSource.domElement (si AR.js ya cre칩 el video)
      - logs para diagn칩stico
    -->
    <script>
      // Espera que AR.js cree arToolkitSource y su domElement (video)
      function waitForArToolkitSource(timeoutMs = 10000) {
        const scene = document.getElementById('scene');
        return new Promise((resolve, reject) => {
          let waited = 0;
          const step = 200;
          const check = () => {
            if (scene && scene.systems && scene.systems.arjs && scene.systems.arjs.arToolkitSource && scene.systems.arjs.arToolkitSource.domElement) {
              resolve(scene.systems.arjs.arToolkitSource);
            } else {
              waited += step;
              if (waited >= timeoutMs) reject(new Error('arToolkitSource no listo (timeout)'));
              else setTimeout(check, step);
            }
          };
          check();
        });
      }

      async function selectCameraAndStart() {
        const scene = document.getElementById('scene');
        if (!scene) return;
        try {
          console.log('[camera-select] pidiendo permiso con baja resoluci칩n (ideal environment)');
          // Pedimos permiso con baja resoluci칩n primero para evitar que el sistema seleccione telefoto
          await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: { ideal: "environment" },
              width: { ideal: 640 },   // baja resoluci칩n preferida inicialmente
              height: { ideal: 480 },
              aspectRatio: 16/9
            }
          });

          // Ahora que hay permiso, enumeramos c치maras
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(d => d.kind === 'videoinput' && d.deviceId);
          console.log('[camera-select] c치maras encontradas:', videoDevices.map(v=>v.label || v.deviceId));

          // Busca nombre que sugiera gran angular
          const wideCam = videoDevices.find(d => /wide|ultra|ultrawide|widelens/i.test(d.label));
          if (!wideCam) {
            console.log('[camera-select] no se detect칩 c치mara con "wide" en el label, usaremos c치mara trasera por defecto (baja resoluci칩n pedida).');
            return;
          }

          console.log('[camera-select] intentaremos usar wide camera:', wideCam.label || wideCam.deviceId);

          // Pedir stream expl칤cito de esa c치mara (mayor resoluci칩n)
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              deviceId: { exact: wideCam.deviceId },
              width: { ideal: 1280 },
              height: { ideal: 720 },
              aspectRatio: 16/9
            }
          });

          // Esperamos que AR.js haya creado su elemento <video> para la c치mara
          try {
            const arSource = await waitForArToolkitSource(8000);
            // asignamos el stream al elemento de AR.js
            // Nota: arSource.domElement es el <video> que AR.js usa internamente.
            arSource.domElement.srcObject = stream;
            // forzamos reproducci칩n
            arSource.domElement.play().catch(e => console.warn('[camera-select] play() fall칩:', e));
            console.log('[camera-select] stream wide asignado al arToolkitSource');
          } catch (err) {
            console.warn('[camera-select] arToolkitSource no listo para asignar stream: ', err);
          }
        } catch (err) {
          console.warn('[camera-select] fallo al pedir permiso o asignar c치mara:', err);
          // No hacemos nada: AR.js seguir치 con la c치mara por defecto
        }
      }

      // iniciar intento
      window.addEventListener('load', () => {
        // ejecutamos sin bloquear: la calibraci칩n posterior se encargar치 de alinear el video
        selectCameraAndStart().catch(e => console.warn(e));
      });
    </script>
  </head>

  <body style="margin:0; overflow:hidden;">
    <!-- Overlay -->
    <div id="overlay">
      <div>
        <p>游녡 Toca la pantalla para activar el audio</p>
        <p style="font-size: 0.9rem; opacity: 0.9;">Si es necesario reduce el zoom de tu c치mara. Apunta hacia el marcador.</p>
      </div>
    </div>

    <!-- Escena: incluimos arjs con valores por defecto; luego el script intentar치 reemplazar stream si encuentra wide -->
    <a-scene
      id="scene"
      vr-mode-ui="enabled:false"
      loading-screen="enabled:false"
      embedded
      gesture-detector
      arjs="sourceType: webcam; debugUIEnabled: false; sourceWidth: 1280; sourceHeight: 720; displayWidth: 1280; displayHeight: 720;">

      <a-assets>
        <video id="vid"
               src="assets/asset.mp4"
               preload="auto"
               loop
               crossorigin="anonymous"
               playsinline
               webkit-playsinline></video>
      </a-assets>

      <!-- Marcador y handler -->
      <a-marker type="pattern"
                preset="custom"
                url="assets/marker.patt"
                id="markerA"
                videohandler
                smooth="true"
                smoothCount="10"
                smoothTolerance="0.01"
                smoothThreshold="5"
                raycaster="objects:.clickable"
                emitevents="true"
                cursor="fuse:false;rayOrigin:mouse">

        <a-video src="#vid"
                 id="videoPlane"
                 scale="1 1 1"
                 position="0 0 0"
                 rotation="-90 0 0"
                 class="clickable"
                 gesture-handler></a-video>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>

    <!-- Componente videohandler: reproduce, y calibra proyecci칩n + recentra el a-video -->
    <script>
      AFRAME.registerComponent('videohandler', {
        init: function () {
          const marker = this.el;                    // <a-marker>
          const vidEl = document.getElementById('vid'); // video asset que reproduces como textura
          const overlay = document.getElementById('overlay');
          const scene = document.getElementById('scene');
          const videoPlaneSelector = '#videoPlane';
          let tapDone = false;
          let markerOn = false;

          // iOS tweaks (para evitar cuadro negro / autoplay)
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                        (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

          if (isIOS) {
            vidEl.setAttribute('muted', 'true');
            vidEl.setAttribute('playsinline', 'true');
            vidEl.setAttribute('webkit-playsinline', 'true');
            vidEl.muted = true;
            vidEl.load();
          }

          // Unlock audio on first tap
          const unlock = () => {
            tapDone = true;
            if (overlay) overlay.style.display = 'none';
            tryPlay();
            window.removeEventListener('click', unlock);
            window.removeEventListener('touchend', unlock);
          };
          window.addEventListener('click', unlock);
          window.addEventListener('touchend', unlock);

          // Espera que AR.js cree arToolkitSource y su <video> (la c치mara)
          const waitForArToolkitSource = (timeoutMs = 10000) => {
            return new Promise((resolve, reject) => {
              let waited = 0;
              const step = 200;
              const check = () => {
                if (scene && scene.systems && scene.systems.arjs && scene.systems.arjs.arToolkitSource && scene.systems.arjs.arToolkitSource.domElement) {
                  resolve(scene.systems.arjs.arToolkitSource);
                } else {
                  waited += step;
                  if (waited >= timeoutMs) reject(new Error('arToolkitSource no listo'));
                  else setTimeout(check, step);
                }
              };
              check();
            });
          };

          // Ajusta la proyecci칩n de la c치mara three.js para que coincida con el tama침o real del stream de c치mara
          function calibrateProjectionOnce(arSource) {
            try {
              const camVideo = arSource.domElement; // <video> del stream de la c치mara
              const vw = camVideo.videoWidth || camVideo.width;
              const vh = camVideo.videoHeight || camVideo.height;
              if (vw && vh && scene.camera) {
                // ajustar aspect y actualizar proyecci칩n
                scene.camera.aspect = vw / vh;
                scene.camera.updateProjectionMatrix();

                // ajustar tama침o del renderer para que se comporte con la relaci칩n del video
                if (scene.renderer) {
                  const displayW = window.innerWidth;
                  const displayH = Math.round(displayW * (vh / vw));
                  scene.renderer.setSize(displayW, displayH);
                }
                console.log('[calibrate] camera aspect actualizado a', (vw/vh).toFixed(3), 'size:', vw, vh);
              } else {
                console.log('[calibrate] no hay dimensiones del video de c치mara a칰n', vw, vh);
              }
            } catch (e) {
              console.warn('[calibrate] error:', e);
            }
          }

          // Re-centra el video (a-video) dentro del marcador (posici칩n local 0,0,0 y rotaci칩n plana)
          function recenterVideoPlane() {
            const markerEl = document.getElementById('markerA');
            if (!markerEl) return;
            const videoPlane = markerEl.querySelector(videoPlaneSelector);
            if (!videoPlane) return;
            // Forzamos la posici칩n/rotaci칩n/escala por si el FOV/ASPECT anterior produjo offset visual.
            videoPlane.setAttribute('position', '0 0 0');
            videoPlane.setAttribute('rotation', '-90 0 0');
            // opcional: restablecemos escala a 1 (si tienes transformaciones previas por gestures se mantendr치n)
            //videoPlane.setAttribute('scale', '1 1 1');

            // tambi칠n actualizamos su matrix3D inmediatamente
            if (videoPlane.object3D) {
              videoPlane.object3D.updateMatrixWorld(true);
            }
            console.log('[recenter] videoPlane recentrado en marcador');
          }

          // Calibraci칩n completa: intenta varias veces para estabilizar
          async function runCalibrationAttempts(times = 3, intervalMs = 400) {
            try {
              const arSource = await waitForArToolkitSource(8000);
              for (let i = 0; i < times; i++) {
                calibrateProjectionOnce(arSource);
                recenterVideoPlane();
                await new Promise(r => setTimeout(r, intervalMs));
              }
            } catch (err) {
              console.warn('[runCalibrationAttempts] no se pudo obtener arToolkitSource:', err);
            }
          }

          // Reproduce si se ha desbloqueado y el marcador est치 visible
          function tryPlay() {
            if (tapDone && markerOn) {
              if (isIOS) {
                vidEl.muted = true;
                vidEl.play().then(() => {
                  setTimeout(() => vidEl.muted = false, 100);
                }).catch(e => console.warn('play iOS:', e));
              } else {
                vidEl.muted = false;
                vidEl.play().catch(e => console.warn('play:', e));
              }
            }
          }

          // Marker events
          marker.addEventListener('markerFound', () => {
            markerOn = true;
            tryPlay();
            // esperamos un poco y ejecutamos calibraciones repetidas para estabilizar
            runCalibrationAttempts(4, 400).catch(e => console.warn(e));
          });

          marker.addEventListener('markerLost', () => {
            markerOn = false;
            // pausamos el video cuando se pierde el marcador
            try { vidEl.pause(); } catch (e) {}
          });

          // Si el usuario hace interacci칩n t치ctil (por ejemplo hace zoom out), recalibramos tras finalizar interacci칩n.
          let touchTimer = null;
          function scheduleRecalibrationAfterInteraction() {
            if (touchTimer) clearTimeout(touchTimer);
            touchTimer = setTimeout(() => {
              // s칩lo recalibrar si marcador est치 visible
              if (markerOn) runCalibrationAttempts(3, 350).catch(e => console.warn(e));
            }, 350); // espera corto para que el zoom termine
          }
          window.addEventListener('touchend', scheduleRecalibrationAfterInteraction, false);
          window.addEventListener('mouseup', scheduleRecalibrationAfterInteraction, false);

          // ALSO: cuando la c치mara del AR.js carga metadata (dimensiones reales), calibramos inmediatamente
          waitForArToolkitSource(10000).then(arSource => {
            // si el video ya tiene metadata, calibramos; si no, atachamos listener.
            const camVideo = arSource.domElement;
            if (camVideo && (camVideo.readyState >= 1 || camVideo.videoWidth)) {
              // ya tenemos dimensiones
              calibrateProjectionOnce(arSource);
            } else if (camVideo) {
              camVideo.addEventListener('loadedmetadata', () => {
                calibrateProjectionOnce(arSource);
              });
            }
          }).catch(err => {
            console.warn('[videohandler] arToolkitSource no disponible para calibrar autom치ticamente:', err);
          });

        } // init end
      }); // registerComponent end
    </script>

    <!-- Componente videohandler original (solo se us칩 el nuevo para reproduccion/calibracion) -->
    <script>
      // Mantener la l칩gica original de desbloqueo + reproducci칩n (ya integrada en videohandler arriba)
      // (invisible placeholder para mantener coherencia; la funcionalidad se implement칩 en el componente anterior)
    </script>
  </body>
</html>
